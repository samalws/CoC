[minitrue doesn't have the "->" symbol built in, so we need to define it]
-> = λa:*.λb:*.∀x:a.b;

[function composition is also not built in, so we need to define that]
comp = λa:*.λb:*.λc:*. λf:(-> a b).λg:(-> b c). λx:a.g (f x);
comp : ∀a:*.∀b:*.∀c:*. -> (-> a b) (-> (-> b c) (-> a c));

[note that we check the type of comp after we define it, not before]
[you can reference code written in previous lines, but not code that hasn't been reached yet]
[note also that comp is able to use -> in its definition. if we defined comp before ->, then we wouldn't be able to do this]

[identity function and its type]
id = λa:*.λx:a.x;
idT = λa:*.-> a a;
id : ∀a:*.idT a;

const = λa:*.λb:*.λx:a.λy:b.x;
const : ∀a:*.∀b:*.(-> a (-> b a));
ignore = λa:*.λb:*.λx:a.λy:b.y;

[equality]
eq = λa:*. λb:a.λc:a. ∀f:(∀x:a.*). -> (f b) (f c);
eq : ∀a:*. ∀b:a.∀c:a. *;

[proof eq is reflexive]
eqRefl = λa:*. λb:a. λf:(∀x:a.*). λfb:(f b). fb;
eqRefl : ∀a:*. ∀b:a. eq a b b;

[proof eq is transitive]
eqTrans = λa:*. λb:a.λc:a.λd:a. λebc:(eq a b c).λecd:(eq a c d). 
          λf:(∀x:a.*). comp (f b) (f c) (f d) (ebc f) (ecd f);
eqTrans : ∀a:*. ∀b:a.∀c:a.∀d:a. -> (eq a b c) (-> (eq a c d) (eq a b d));

[proof eq is symmetric]
eqSymm = λa:*. λb:a.λc:a. λebc:(eq a b c).
         ebc (λx:a. eq a x b) (eqRefl a b);
eqSymm : ∀a:*. ∀b:a.∀c:a. -> (eq a b c) (eq a c b);

[the natural numbers]
nat = ∀a:*.idT (idT a);
zero = λa:*.const (idT a) (idT a) (id a);
zero : nat;
succ = λn:nat.λa:*.λf:(idT a).λx:a.n a f (f x);
succ : idT nat;
add = λn:nat.λm:nat.n nat succ m;
add : -> nat (idT nat);
